012_0321_3210
Symmetry: False
Non-Interleaving Decompoition: False
Tiling Queue: <class 'atrapv2.tilingqueuedf.TilingQueueDF'>

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:49:14

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.206892490386963 seconds
Number of tilings expanded by Set 1 is 353
Number of tilings expanded by Set 2 is 248
Total number of tilings is 1631
Total number of expandable tilings is 1347
Total number of verified tilings is 171
Total number of strategy verified tilings is 98
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.4838547706604004 seconds, ~1%
Time spent strategy verifying: 0.1166982650756836 seconds, ~0%
Time spent inferring: 6.921042442321777 seconds, ~22%
Time spent expanding Set 1: 11.013211488723755 seconds, ~36%
Time spent expanding Set 2: 0.5225930213928223 seconds, ~1%
Time spent queueing: 0.7960813045501709 seconds, ~2%
Time spent prepping for tree search: 1.9943349361419678 seconds, ~6%
Time spent searching for tree: 3.9707744121551514 seconds, ~13%
Total of ~81% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:49:44

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.00884771347046 seconds
Number of tilings expanded by Set 1 is 390
Number of tilings expanded by Set 2 is 250
Total number of tilings is 1724
Total number of expandable tilings is 1350
Total number of verified tilings is 171
Total number of strategy verified tilings is 98
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.48662900924682617 seconds, ~1%
Time spent strategy verifying: 0.11880993843078613 seconds, ~0%
Time spent inferring: 7.20444393157959 seconds, ~24%
Time spent expanding Set 1: 9.367142915725708 seconds, ~31%
Time spent expanding Set 2: 0.5231037139892578 seconds, ~1%
Time spent queueing: 0.862816333770752 seconds, ~2%
Time spent prepping for tree search: 2.354032039642334 seconds, ~7%
Time spent searching for tree: 4.656221866607666 seconds, ~15%
Total of ~81% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:50:14

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.10571789741516 seconds
Number of tilings expanded by Set 1 is 309
Number of tilings expanded by Set 2 is 162
Total number of tilings is 970
Total number of expandable tilings is 896
Total number of verified tilings is 93
Total number of strategy verified tilings is 39
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.5750935077667236 seconds, ~1%
Time spent strategy verifying: 0.050653934478759766 seconds, ~0%
Time spent inferring: 12.13535189628601 seconds, ~40%
Time spent expanding Set 1: 13.639583349227905 seconds, ~45%
Time spent expanding Set 2: 0.22968745231628418 seconds, ~0%
Time spent queueing: 0.25844669342041016 seconds, ~0%
Time spent prepping for tree search: 0.7043249607086182 seconds, ~2%
Time spent searching for tree: 1.332864761352539 seconds, ~4%
Total of ~92% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:50:44

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.208459854125977 seconds
Number of tilings expanded by Set 1 is 309
Number of tilings expanded by Set 2 is 253
Total number of tilings is 1569
Total number of expandable tilings is 1495
Total number of verified tilings is 92
Total number of strategy verified tilings is 38
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 1.092505693435669 seconds, ~3%
Time spent strategy verifying: 0.04964923858642578 seconds, ~0%
Time spent inferring: 17.031842947006226 seconds, ~56%
Time spent expanding Set 1: 5.538011074066162 seconds, ~18%
Time spent expanding Set 2: 0.4576411247253418 seconds, ~1%
Time spent queueing: 0.4124753475189209 seconds, ~1%
Time spent prepping for tree search: 1.2714498043060303 seconds, ~4%
Time spent searching for tree: 1.6867079734802246 seconds, ~5%
Total of ~88% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:51:15

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.08426523208618 seconds
Number of tilings expanded by Set 1 is 195
Number of tilings expanded by Set 2 is 126
Total number of tilings is 1002
Total number of expandable tilings is 952
Total number of verified tilings is 140
Total number of strategy verified tilings is 59
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 0.9165420532226562 seconds, ~3%
Time spent strategy verifying: 0.06491518020629883 seconds, ~0%
Time spent inferring: 15.565857648849487 seconds, ~51%
Time spent expanding Set 1: 10.257946968078613 seconds, ~34%
Time spent expanding Set 2: 0.20785117149353027 seconds, ~0%
Time spent queueing: 0.20613598823547363 seconds, ~0%
Time spent prepping for tree search: 0.5737926959991455 seconds, ~1%
Time spent searching for tree: 1.1140697002410889 seconds, ~3%
Total of ~92% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:51:45

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.196940660476685 seconds
Number of tilings expanded by Set 1 is 289
Number of tilings expanded by Set 2 is 170
Total number of tilings is 1355
Total number of expandable tilings is 1269
Total number of verified tilings is 181
Total number of strategy verified tilings is 61
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 1.6114792823791504 seconds, ~5%
Time spent strategy verifying: 0.07304716110229492 seconds, ~0%
Time spent inferring: 18.66491460800171 seconds, ~61%
Time spent expanding Set 1: 4.662011384963989 seconds, ~15%
Time spent expanding Set 2: 0.3002045154571533 seconds, ~0%
Time spent queueing: 0.325580358505249 seconds, ~1%
Time spent prepping for tree search: 1.0617265701293945 seconds, ~3%
Time spent searching for tree: 1.9598259925842285 seconds, ~6%
Total of ~91% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:52:15

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 5.939176082611084 seconds
Number of tilings expanded by Set 1 is 120
Number of tilings expanded by Set 2 is 78
Total number of tilings is 532
Total number of expandable tilings is 281
Total number of verified tilings is 208
Total number of strategy verified tilings is 82
Total number of empty tilings is 3
There were 0 cache misses

Time spent equivalent expanding: 0.06239676475524902 seconds, ~1%
Time spent strategy verifying: 0.062276363372802734 seconds, ~1%
Time spent inferring: 1.134007453918457 seconds, ~19%
Time spent expanding Set 1: 1.5589592456817627 seconds, ~26%
Time spent expanding Set 2: 0.0970923900604248 seconds, ~1%
Time spent queueing: 0.9174845218658447 seconds, ~15%
Time spent prepping for tree search: 0.26634693145751953 seconds, ~4%
Time spent searching for tree: 1.0513145923614502 seconds, ~17%
Total of ~84% accounted for.

Proof tree found Mon, 18 Sep 2017 14:52:21

root: 0
      ├─────1
      └─────2
            ├─────3
            └─────4
                  ├─────5
                  │     ├─────6
                  │     │     ├─────7
                  │     │     └─────8
                  │     │           ├─────9
                  │     │           │     ├─────10
                  │     │           │     └─────11
                  │     │           └─────12
                  │     │                 ├─────13
                  │     │                 │     ├─────14
                  │     │                 │     └─────15
                  │     │                 └─────16
                  │     │                       ├─────17
                  │     │                       └─────18
                  │     └─────19
                  │           ├─────20
                  │           │     ├─────21
                  │           │     └─────22
                  │           └─────23
                  │                 ├─────24
                  │                 │     ├─────25
                  │                 │     └─────26
                  │                 └─────27
                  │                       ├─────28
                  │                       └─────29
                  └─────30

Label: 0

+-+
|1|
+-+
1: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0)))

Label: 1

+-+
| |
+-+


Label: 2

+-+
|1|
+-+
1: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0)))
We use his sibling for the next strategy
+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: Av(Perm((0, 1, 2)), Perm((2, 1, 0)))
3: point

Label: 3

+-+-+
|2| |
+-+-+
| |1|
+-+-+
1: Av(Perm((0, 1, 2)), Perm((2, 1, 0)))
2: point

Label: 4

+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: Av(Perm((0, 1, 2)), Perm((2, 1, 0)))
3: point

Label: 5

+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))
3: point

Label: 6

+-+-+-+-+
| | |3| |
+-+-+-+-+
|3| | | |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))
3: point

Label: 7

+-+-+-+
| |2| |
+-+-+-+
|2| | |
+-+-+-+
| | |1|
+-+-+-+
1: Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))
2: point

Label: 8

+-+-+-+-+
| | |3| |
+-+-+-+-+
|3| | | |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: Av+(Perm((0, 1)), Perm((2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((1, 0, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)))
3: point

Label: 9

+-+-+-+-+-+
| | | |3| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| |3| | | |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((1, 0)), Perm((0, 1, 2)))
3: point
We use his sibling for the next strategy
+-+-+-+-+-+-+
| | | |2| | |
+-+-+-+-+-+-+
|2| | | | | |
+-+-+-+-+-+-+
| |2| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
| | |1| | | |
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: point

Label: 10

+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
|2| | | | |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: point

Label: 11

+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
|1| | | | |
+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point

Label: 12

+-+-+-+-+-+-+
| | |4| | | |
+-+-+-+-+-+-+
|4| | | | | |
+-+-+-+-+-+-+
| | | | |4| |
+-+-+-+-+-+-+
| |3| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: Av+(Perm((0, 1)), Perm((2, 1, 0)))
4: point
We use his sibling for the next strategy
+-+-+-+-+-+-+-+
| | | |3| | | |
+-+-+-+-+-+-+-+
|3| | | | | | |
+-+-+-+-+-+-+-+
| | | | | |3| |
+-+-+-+-+-+-+-+
| |3| | | | | |
+-+-+-+-+-+-+-+
| | |1| | | | |
+-+-+-+-+-+-+-+
| | | | | | |2|
+-+-+-+-+-+-+-+
| | | | |1| | |
+-+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: point

Label: 13

+-+-+-+-+-+-+
| | | |2| | |
+-+-+-+-+-+-+
|2| | | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| |2| | | | |
+-+-+-+-+-+-+
| | |1| | | |
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: point

Label: 14

+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
|2| | | | |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: point

Label: 15

+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
|1| | | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point

Label: 16

+-+-+-+-+-+-+
| | |3| | | |
+-+-+-+-+-+-+
|3| | | | | |
+-+-+-+-+-+-+
| | | | |3| |
+-+-+-+-+-+-+
| |3| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((1, 0)), Perm((0, 1, 2)))
3: point

Label: 17

+-+-+-+-+-+
| | |2| | |
+-+-+-+-+-+
|2| | | | |
+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
1: Av+(Perm((1, 0)), Perm((0, 1, 2)))
2: point
We use his sibling for the next strategy
+-+-+-+-+-+-+
| | |1| | | |
+-+-+-+-+-+-+
|1| | | | | |
+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
| |1| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
1: point
2: Av(Perm((0, 1)), Perm((1, 0)))

Label: 18

+-+-+-+-+-+-+
| | |1| | | |
+-+-+-+-+-+-+
|1| | | | | |
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
| |1| | | | |
+-+-+-+-+-+-+
| | | | | |1|
+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
1: point

Label: 19

+-+-+-+-+-+
| |4| | | |
+-+-+-+-+-+
| | | |4| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| | |1| |2|
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))
4: point
We use his sibling for the next strategy
+-+-+-+-+-+-+
| | |3| | | |
+-+-+-+-+-+-+
| | | | |3| |
+-+-+-+-+-+-+
|3| | | | | |
+-+-+-+-+-+-+
| |1| | | | |
+-+-+-+-+-+-+
| | | |1| |2|
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: point

Label: 20

+-+-+-+-+-+
| |3| | | |
+-+-+-+-+-+
| | | |3| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| | |1| |2|
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: point

Label: 21

+-+
|1|
+-+
1: point

Label: 22

+-+-+-+-+
|3| | | |
+-+-+-+-+
| | |3| |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: point
We use his sibling for the next strategy
+-+-+
|2| |
+-+-+
| |1|
+-+-+
1: Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))
2: point

Label: 23

+-+-+-+-+-+-+
| | |4| | | |
+-+-+-+-+-+-+
| | | | |4| |
+-+-+-+-+-+-+
|4| | | | | |
+-+-+-+-+-+-+
| |3| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: Av+(Perm((0, 1)), Perm((2, 1, 0)))
4: point

Label: 24

+-+-+-+-+-+
| | |3| | |
+-+-+-+-+-+
| | | | |3|
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((0, 1)), Perm((2, 1, 0)))
3: point

Label: 25

+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
|1| | | | |
+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point

Label: 26

+-+-+-+-+
| | |2| |
+-+-+-+-+
| | | |2|
+-+-+-+-+
|2| | | |
+-+-+-+-+
| |1| | |
+-+-+-+-+
1: Av+(Perm((0, 1)), Perm((2, 1, 0)))
2: point

Label: 27

+-+-+-+-+-+-+
| | |3| | | |
+-+-+-+-+-+-+
| | | | |3| |
+-+-+-+-+-+-+
|3| | | | | |
+-+-+-+-+-+-+
| |3| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((1, 0)), Perm((0, 1, 2)))
3: point

Label: 28

+-+
|1|
+-+
1: point

Label: 29

+-+-+-+-+-+
| | | |3| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| |3| | | |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((1, 0)), Perm((0, 1, 2)))
3: point

Label: 30

+-+-+
| |2|
+-+-+
|1| |
+-+-+
1: Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: point
{"root": {"formal_step": "We perform cell insertion into cell (0, 0); either it is empty or Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0))).", "in_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0)))"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0)))"}, "relation": "", "identifier": 0, "children": [{"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {}, "out_tiling": {}, "relation": "", "identifier": 1, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (0, 0); either it is empty or Av+(Perm((0, 1)), Perm((3, 2, 1, 0))).", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((3, 2, 1, 0)))"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[1, 1]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=0, j=0). | ", "identifier": 3, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[1, 0]": "Av(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[0, 1]": "point"}, "out_tiling": {"[1, 0]": "Av(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[0, 1]": "point"}, "relation": "", "identifier": 7, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (2, 0); either it is empty or Av+(Perm((0, 1, 2)), Perm((2, 1, 0))).", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[1, 1]": "point"}, "relation": "", "identifier": 8, "children": [{"formal_step": "Placing the maximum point into row 0", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[1, 1]": "point"}, "relation": "", "identifier": 18, "children": [{"formal_step": "We perform cell insertion into cell (1, 0); either it is empty or Av+(Perm((0, 1)), Perm((2, 1, 0))).", "in_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[0, 1]": "point", "[2, 2]": "point"}, "out_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[0, 1]": "point", "[2, 2]": "point"}, "relation": "", "identifier": 26, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[0, 1]": "point", "[1, 2]": "point"}, "out_tiling": {"[2, 0]": "Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[0, 1]": "point", "[1, 2]": "point"}, "relation": "", "identifier": 58, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "Placing the maximum point into row 0", "in_tiling": {"[1, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 0, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)))", "[0, 1]": "point", "[2, 2]": "point"}, "out_tiling": {"[1, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 0, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)))", "[0, 1]": "point", "[2, 2]": "point"}, "relation": "", "identifier": 57, "children": [{"formal_step": "We perform cell insertion into cell (4, 1); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "point", "[3, 4]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 2]": "point", "[1, 3]": "point", "[0, 4]": "point", "[3, 5]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=4, j=1). | ", "identifier": 200, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 1]": "point", "[1, 2]": "point", "[0, 3]": "point", "[3, 4]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 1]": "point", "[1, 2]": "point", "[0, 3]": "point", "[3, 4]": "point"}, "relation": "", "identifier": 402, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "point", "[4, 1]": "point", "[1, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[3, 0]": "point", "[4, 1]": "point", "[1, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "relation": "", "identifier": 403, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "We perform cell insertion into cell (6, 1); either it is empty or Av+(Perm((1, 0)), Perm((0, 1, 2))).", "in_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[4, 3]": "point", "[0, 4]": "point", "[2, 5]": "point"}, "out_tiling": {"[4, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[6, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 2]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 3]": "point", "[5, 4]": "point", "[0, 5]": "point", "[3, 6]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=1, j=2). | ", "identifier": 202, "children": [{"formal_step": "We perform cell insertion into cell (4, 0); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[4, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[2, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 2]": "point", "[5, 3]": "point", "[0, 4]": "point", "[3, 5]": "point"}, "out_tiling": {"[4, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[2, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 2]": "point", "[5, 3]": "point", "[0, 4]": "point", "[3, 5]": "point"}, "relation": "", "identifier": 415, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 1]": "point", "[4, 2]": "point", "[0, 3]": "point", "[3, 4]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 1]": "point", "[4, 2]": "point", "[0, 3]": "point", "[3, 4]": "point"}, "relation": "", "identifier": 530, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "point", "[1, 1]": "point", "[4, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[3, 0]": "point", "[1, 1]": "point", "[4, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "relation": "", "identifier": 531, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "We perform cell insertion into cell (3, 0); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[4, 3]": "point", "[0, 4]": "point", "[2, 5]": "point"}, "out_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[4, 3]": "point", "[0, 4]": "point", "[2, 5]": "point"}, "relation": "", "identifier": 410, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[4, 0]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 1]": "point", "[3, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[4, 0]": "point", "[5, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 2]": "point", "[3, 3]": "point", "[0, 4]": "point", "[2, 5]": "point"}, "relation": "| Inserting the bottom most point in to the cell Cell(i=4, j=0). | ", "identifier": 528, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "point", "[5, 1]": "point", "[1, 2]": "point", "[4, 3]": "point", "[0, 4]": "point", "[2, 5]": "point"}, "out_tiling": {"[3, 0]": "point", "[5, 1]": "point", "[1, 2]": "point", "[4, 3]": "point", "[0, 4]": "point", "[2, 5]": "point"}, "relation": "", "identifier": 527, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "We perform cell insertion into cell (1, 1); either it is empty or Av+(Perm((0, 1)), Perm((2, 1, 0))).", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[4, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[0, 1]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[5, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 1]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 2]": "point", "[4, 3]": "point", "[2, 4]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=0, j=1). | ", "identifier": 28, "children": [{"formal_step": "Reversibly delete the blocks at cells [Cell(i=0, j=1)]", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[4, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[4, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 72, "children": [{"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {"[0, 0]": "point"}, "out_tiling": {"[0, 0]": "point"}, "relation": "", "identifier": 5, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 1]": "point", "[0, 2]": "point"}, "out_tiling": {"[1, 0]": "Av+(Perm((0, 1, 2)), Perm((2, 1, 0)))", "[0, 1]": "point"}, "relation": "| Reverse of: Inserting the top most point in to the cell Cell(i=1, j=0). | ", "identifier": 19, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[{Cell(i=0, j=2): Cell(i=1, j=3), Cell(i=1, j=0): Cell(i=2, j=0), Cell(i=2, j=1): Cell(i=3, j=2), Cell(i=3, j=0): Cell(i=4, j=0)}, {Cell(i=0, j=0): Cell(i=0, j=1)}]", "strategy_verified": false}, {"formal_step": "We perform cell insertion into cell (5, 1); either it is empty or Av+(Perm((1, 0)), Perm((0, 1, 2))).", "in_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 3]": "point", "[4, 4]": "point", "[2, 5]": "point"}, "out_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 3]": "point", "[4, 4]": "point", "[2, 5]": "point"}, "relation": "", "identifier": 74, "children": [{"formal_step": "We perform cell insertion into cell (3, 0); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 1]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 2]": "point", "[4, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 1]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 2]": "point", "[4, 3]": "point", "[2, 4]": "point"}, "relation": "", "identifier": 156, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "point", "[1, 1]": "point", "[0, 2]": "point", "[4, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[3, 0]": "point", "[1, 1]": "point", "[0, 2]": "point", "[4, 3]": "point", "[2, 4]": "point"}, "relation": "", "identifier": 320, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[1, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[3, 2]": "point", "[2, 3]": "point"}, "out_tiling": {"[1, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[3, 2]": "point", "[2, 3]": "point"}, "relation": "", "identifier": 348, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "Reversibly delete the blocks at cells [Cell(i=2, j=5)]", "in_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "point", "[4, 4]": "point", "[2, 5]": "point"}, "out_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "point", "[4, 4]": "point", "[2, 5]": "point"}, "relation": "", "identifier": 162, "children": [{"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {"[0, 0]": "point"}, "out_tiling": {"[0, 0]": "point"}, "relation": "", "identifier": 5, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "recurse", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "point", "[3, 4]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "point", "[3, 4]": "point"}, "relation": "", "identifier": 200, "children": [], "recurse": "[]", "strategy_verified": false}], "recurse": "[{Cell(i=0, j=3): Cell(i=0, j=3), Cell(i=1, j=2): Cell(i=1, j=2), Cell(i=2, j=0): Cell(i=3, j=0), Cell(i=3, j=4): Cell(i=4, j=4), Cell(i=4, j=1): Cell(i=5, j=1)}, {Cell(i=0, j=0): Cell(i=2, j=5)}]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[1, 1]": "point"}, "relation": "", "identifier": 22, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}}
Time taken was 5.939176082611084 seconds

