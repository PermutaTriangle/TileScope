012_1032_3120_3210
Symmetry: False
Non-Interleaving Decompoition: False
Tiling Queue: <class 'atrapv2.tilingqueuedf.TilingQueueDF'>

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 15:27:05

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.02009415626526 seconds
Number of tilings expanded by Set 1 is 440
Number of tilings expanded by Set 2 is 288
Total number of tilings is 1655
Total number of expandable tilings is 1292
Total number of verified tilings is 241
Total number of strategy verified tilings is 124
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.36772751808166504 seconds, ~1%
Time spent strategy verifying: 0.09986448287963867 seconds, ~0%
Time spent inferring: 5.877976655960083 seconds, ~19%
Time spent expanding Set 1: 9.476342916488647 seconds, ~31%
Time spent expanding Set 2: 0.48652148246765137 seconds, ~1%
Time spent queueing: 0.9220366477966309 seconds, ~3%
Time spent prepping for tree search: 2.7255866527557373 seconds, ~9%
Time spent searching for tree: 6.172333717346191 seconds, ~20%
Total of ~84% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 15:27:35

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.00805115699768 seconds
Number of tilings expanded by Set 1 is 449
Number of tilings expanded by Set 2 is 307
Total number of tilings is 1680
Total number of expandable tilings is 1312
Total number of verified tilings is 272
Total number of strategy verified tilings is 126
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.37506532669067383 seconds, ~1%
Time spent strategy verifying: 0.10337495803833008 seconds, ~0%
Time spent inferring: 5.887268781661987 seconds, ~19%
Time spent expanding Set 1: 7.61330771446228 seconds, ~25%
Time spent expanding Set 2: 0.5038142204284668 seconds, ~1%
Time spent queueing: 1.0576343536376953 seconds, ~3%
Time spent prepping for tree search: 3.1215553283691406 seconds, ~10%
Time spent searching for tree: 7.304687023162842 seconds, ~24%
Total of ~83% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 15:28:05

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.12767267227173 seconds
Number of tilings expanded by Set 1 is 338
Number of tilings expanded by Set 2 is 316
Total number of tilings is 1628
Total number of expandable tilings is 1544
Total number of verified tilings is 76
Total number of strategy verified tilings is 48
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 1.075120210647583 seconds, ~3%
Time spent strategy verifying: 0.047421932220458984 seconds, ~0%
Time spent inferring: 12.461091756820679 seconds, ~41%
Time spent expanding Set 1: 9.10803747177124 seconds, ~30%
Time spent expanding Set 2: 0.5067329406738281 seconds, ~1%
Time spent queueing: 0.5572795867919922 seconds, ~1%
Time spent prepping for tree search: 1.480283498764038 seconds, ~4%
Time spent searching for tree: 1.7857460975646973 seconds, ~5%
Total of ~85% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 15:28:35

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.01188087463379 seconds
Number of tilings expanded by Set 1 is 399
Number of tilings expanded by Set 2 is 363
Total number of tilings is 1756
Total number of expandable tilings is 1643
Total number of verified tilings is 97
Total number of strategy verified tilings is 53
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 1.0615527629852295 seconds, ~3%
Time spent strategy verifying: 0.0492405891418457 seconds, ~0%
Time spent inferring: 14.132062196731567 seconds, ~47%
Time spent expanding Set 1: 5.300607204437256 seconds, ~17%
Time spent expanding Set 2: 0.5361807346343994 seconds, ~1%
Time spent queueing: 0.8332071304321289 seconds, ~2%
Time spent prepping for tree search: 2.3282265663146973 seconds, ~7%
Time spent searching for tree: 2.537631034851074 seconds, ~8%
Total of ~85% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 15:29:06

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.41002893447876 seconds
Number of tilings expanded by Set 1 is 341
Number of tilings expanded by Set 2 is 218
Total number of tilings is 1441
Total number of expandable tilings is 1363
Total number of verified tilings is 116
Total number of strategy verified tilings is 56
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 1.5482392311096191 seconds, ~5%
Time spent strategy verifying: 0.04444265365600586 seconds, ~0%
Time spent inferring: 13.014278173446655 seconds, ~42%
Time spent expanding Set 1: 9.174190759658813 seconds, ~30%
Time spent expanding Set 2: 0.3334035873413086 seconds, ~1%
Time spent queueing: 0.5277035236358643 seconds, ~1%
Time spent prepping for tree search: 1.421593189239502 seconds, ~4%
Time spent searching for tree: 2.2649781703948975 seconds, ~7%
Total of ~90% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 15:29:36

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.181488752365112 seconds
Number of tilings expanded by Set 1 is 364
Number of tilings expanded by Set 2 is 294
Total number of tilings is 1725
Total number of expandable tilings is 1631
Total number of verified tilings is 135
Total number of strategy verified tilings is 67
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 1.879284381866455 seconds, ~6%
Time spent strategy verifying: 0.06054949760437012 seconds, ~0%
Time spent inferring: 14.145702123641968 seconds, ~46%
Time spent expanding Set 1: 4.629070281982422 seconds, ~15%
Time spent expanding Set 2: 0.4760286808013916 seconds, ~1%
Time spent queueing: 0.6907880306243896 seconds, ~2%
Time spent prepping for tree search: 2.0100958347320557 seconds, ~6%
Time spent searching for tree: 3.114680290222168 seconds, ~10%
Total of ~86% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 15:30:06

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 1.7019977569580078 seconds
Number of tilings expanded by Set 1 is 61
Number of tilings expanded by Set 2 is 40
Total number of tilings is 256
Total number of expandable tilings is 147
Total number of verified tilings is 119
Total number of strategy verified tilings is 50
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.025708913803100586 seconds, ~1%
Time spent strategy verifying: 0.026897192001342773 seconds, ~1%
Time spent inferring: 0.45883822441101074 seconds, ~26%
Time spent expanding Set 1: 0.4392995834350586 seconds, ~25%
Time spent expanding Set 2: 0.03682565689086914 seconds, ~2%
Time spent queueing: 0.15607810020446777 seconds, ~9%
Time spent prepping for tree search: 0.05732607841491699 seconds, ~3%
Time spent searching for tree: 0.30121541023254395 seconds, ~17%
Total of ~84% accounted for.

Proof tree found Mon, 18 Sep 2017 15:30:08

root: 0
      ├─────1
      └─────2
            ├─────3
            └─────4
                  ├─────5
                  └─────6
                        ├─────7
                        │     ├─────8
                        │     └─────9
                        │           ├─────10
                        │           │     ├─────11
                        │           │     └─────12
                        │           └─────13
                        └─────14
                              ├─────15
                              └─────16
                                    ├─────17
                                    │     ├─────18
                                    │     └─────19
                                    └─────20

Label: 0

+-+
|1|
+-+
1: Av(Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0)))

Label: 1

+-+
| |
+-+


Label: 2

+-+
|1|
+-+
1: Av+(Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0)))
We use his sibling for the next strategy
+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))
3: point

Label: 3

+-+-+
|2| |
+-+-+
| |1|
+-+-+
1: Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))
2: point

Label: 4

+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))
3: point

Label: 5

+-+-+
| |2|
+-+-+
|1| |
+-+-+
1: Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: point

Label: 6

+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))
3: point

Label: 7

+-+-+-+-+
| | |3| |
+-+-+-+-+
|3| | | |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))
3: point

Label: 8

+-+-+-+
| |2| |
+-+-+-+
|2| | |
+-+-+-+
| | |1|
+-+-+-+
1: Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))
2: point

Label: 9

+-+-+-+-+
| | |3| |
+-+-+-+-+
|3| | | |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: Av+(Perm((0, 1)), Perm((2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((1, 0, 2)), Perm((1, 2, 0)), Perm((2, 0, 1)), Perm((2, 1, 0)))
3: point

Label: 10

+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
|1| | | | |
+-+-+-+-+-+
| |3| | | |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: point
2: Av+(Perm((0, 1)), Perm((2, 1, 0)))
3: Av(Perm((0, 1)), Perm((1, 0)))
We use his sibling for the next strategy
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
1: point
2: Av(Perm((0, 1)), Perm((1, 0)))
3: Av+(Perm((0, 1)), Perm((2, 1, 0)))

Label: 11

+-+-+-+-+
| | |1| |
+-+-+-+-+
|2| | | |
+-+-+-+-+
| | | |1|
+-+-+-+-+
| |1| | |
+-+-+-+-+
1: point
2: Av+(Perm((0, 1)), Perm((2, 1, 0)))

Label: 12

+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
|1| | | | |
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
1: point

Label: 13

+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
|1| | | | |
+-+-+-+-+-+
| |1| | |2|
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point
2: Av(Perm((0, 1)), Perm((1, 0)))

Label: 14

+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
|2| | | |3|
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: point
3: Av(Perm((1, 0)), Perm((0, 1, 2)))

Label: 15

+-+-+-+-+
| |2| | |
+-+-+-+-+
| | | |2|
+-+-+-+-+
|2| | | |
+-+-+-+-+
| | |1| |
+-+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: point

Label: 16

+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
|2| | | |3|
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: point
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))

Label: 17

+-+-+-+-+
| |1| | |
+-+-+-+-+
| | |1| |
+-+-+-+-+
|1| | |2|
+-+-+-+-+
1: point
2: Av+(Perm((1, 0)), Perm((0, 1, 2)))

Label: 18

+-+-+-+-+
| |1| | |
+-+-+-+-+
| | |1| |
+-+-+-+-+
| | | |1|
+-+-+-+-+
|1| | | |
+-+-+-+-+
1: point

Label: 19

+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
|1| | | |2|
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point
2: Av(Perm((0, 1)), Perm((1, 0)))

Label: 20

+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
|1| | | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
1: point
{"root": {"formal_step": "We perform cell insertion into cell (0, 0); either it is empty or Av+(Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0))).", "in_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0)))"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0)))"}, "relation": "", "identifier": 0, "children": [{"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {}, "out_tiling": {}, "relation": "", "identifier": 1, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (0, 0); either it is empty or Av+(Perm((0, 1)), Perm((3, 2, 1, 0))).", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 0, 3, 2)), Perm((3, 1, 2, 0)), Perm((3, 2, 1, 0)))"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[1, 1]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=0, j=0). | ", "identifier": 3, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[1, 0]": "Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[0, 1]": "point"}, "out_tiling": {"[1, 0]": "Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[0, 1]": "point"}, "relation": "", "identifier": 5, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (2, 0); either it is empty or Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2))).", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[1, 1]": "point"}, "relation": "", "identifier": 6, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[1, 1]": "point"}, "relation": "", "identifier": 15, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "Placing the maximum point into row 0", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((3, 2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[1, 1]": "point"}, "relation": "", "identifier": 14, "children": [{"formal_step": "We perform cell insertion into cell (1, 0); either it is empty or Av+(Perm((0, 1)), Perm((2, 1, 0))).", "in_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[0, 1]": "point", "[2, 2]": "point"}, "out_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[0, 1]": "point", "[2, 2]": "point"}, "relation": "", "identifier": 24, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[0, 1]": "point", "[1, 2]": "point"}, "out_tiling": {"[2, 0]": "Av+(Perm((0, 1, 2)), Perm((1, 2, 0)), Perm((2, 1, 0)), Perm((1, 0, 3, 2)))", "[0, 1]": "point", "[1, 2]": "point"}, "relation": "", "identifier": 71, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "Placing the minimum point into row 0", "in_tiling": {"[1, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((1, 0, 2)), Perm((1, 2, 0)), Perm((2, 0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[2, 2]": "point"}, "out_tiling": {"[1, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((1, 0, 2)), Perm((1, 2, 0)), Perm((2, 0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[2, 2]": "point"}, "relation": "", "identifier": 70, "children": [{"formal_step": "We perform cell insertion into cell (4, 1); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[2, 0]": "point", "[4, 1]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[1, 2]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 3]": "point", "[3, 4]": "point"}, "out_tiling": {"[1, 0]": "point", "[4, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 2]": "point", "[0, 3]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 4]": "point"}, "relation": "| Reverse of: Inserting the top most point in to the cell Cell(i=0, j=2). | Inserting the top most point in to the cell Cell(i=3, j=1). | ", "identifier": 55, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[1, 0]": "point", "[3, 1]": "point", "[0, 2]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 3]": "point"}, "out_tiling": {"[1, 0]": "point", "[3, 1]": "point", "[0, 2]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 3]": "point"}, "relation": "", "identifier": 136, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[1, 0]": "point", "[4, 1]": "point", "[3, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[1, 0]": "point", "[4, 1]": "point", "[3, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "relation": "", "identifier": 135, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "point", "[1, 1]": "point", "[4, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 2]": "point", "[2, 3]": "point"}, "out_tiling": {"[3, 0]": "point", "[1, 1]": "point", "[4, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 2]": "point", "[2, 3]": "point"}, "relation": "", "identifier": 160, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "We perform cell insertion into cell (4, 1); either it is empty or Av+(Perm((1, 0)), Perm((0, 1, 2))).", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[4, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[4, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 25, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 77, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (2, 0); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 1]": "point", "[4, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 1]": "point", "[4, 1]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 78, "children": [{"formal_step": "Placing the minimum point into row 0", "in_tiling": {"[0, 0]": "point", "[3, 0]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 1]": "point", "[1, 2]": "point"}, "out_tiling": {"[0, 0]": "point", "[3, 0]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 1]": "point", "[1, 2]": "point"}, "relation": "", "identifier": 166, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[0, 0]": "point", "[3, 1]": "point", "[2, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[0, 0]": "point", "[3, 1]": "point", "[2, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 171, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "point", "[0, 1]": "point", "[4, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[2, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[3, 0]": "point", "[0, 1]": "point", "[4, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[2, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 252, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "point", "[4, 1]": "point", "[0, 2]": "point", "[3, 3]": "point", "[1, 4]": "point"}, "out_tiling": {"[2, 0]": "point", "[4, 1]": "point", "[0, 2]": "point", "[3, 3]": "point", "[1, 4]": "point"}, "relation": "", "identifier": 168, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}}
Time taken was 1.7019977569580078 seconds

