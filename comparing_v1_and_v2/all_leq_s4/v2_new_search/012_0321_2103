012_0321_2103
Symmetry: False
Non-Interleaving Decompoition: False
Tiling Queue: <class 'atrapv2.tilingqueue.TilingQueue'>

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:44:10

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.185030937194824 seconds
Number of tilings expanded by Set 1 is 257
Number of tilings expanded by Set 2 is 158
Total number of tilings is 1145
Total number of expandable tilings is 1057
Total number of verified tilings is 180
Total number of strategy verified tilings is 91
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.38202524185180664 seconds, ~1%
Time spent strategy verifying: 0.21511244773864746 seconds, ~0%
Time spent inferring: 7.787942409515381 seconds, ~25%
Time spent expanding Set 1: 13.884581327438354 seconds, ~45%
Time spent expanding Set 2: 0.408597469329834 seconds, ~1%
Time spent queueing: 0.017206430435180664 seconds, ~0%
Time spent prepping for tree search: 0.8975965976715088 seconds, ~2%
Time spent searching for tree: 2.3519930839538574 seconds, ~7%
Total of ~81% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:44:40

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.095165729522705 seconds
Number of tilings expanded by Set 1 is 283
Number of tilings expanded by Set 2 is 179
Total number of tilings is 1232
Total number of expandable tilings is 1134
Total number of verified tilings is 221
Total number of strategy verified tilings is 102
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.4168674945831299 seconds, ~1%
Time spent strategy verifying: 0.26657962799072266 seconds, ~0%
Time spent inferring: 8.234136581420898 seconds, ~27%
Time spent expanding Set 1: 11.818371534347534 seconds, ~39%
Time spent expanding Set 2: 0.44188594818115234 seconds, ~1%
Time spent queueing: 0.018958568572998047 seconds, ~0%
Time spent prepping for tree search: 1.1266086101531982 seconds, ~3%
Time spent searching for tree: 3.233741283416748 seconds, ~10%
Total of ~81% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:45:10

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.056168794631958 seconds
Number of tilings expanded by Set 1 is 251
Number of tilings expanded by Set 2 is 104
Total number of tilings is 551
Total number of expandable tilings is 482
Total number of verified tilings is 61
Total number of strategy verified tilings is 39
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.20399165153503418 seconds, ~0%
Time spent strategy verifying: 0.04428911209106445 seconds, ~0%
Time spent inferring: 6.242176294326782 seconds, ~20%
Time spent expanding Set 1: 21.602598905563354 seconds, ~71%
Time spent expanding Set 2: 0.1016991138458252 seconds, ~0%
Time spent queueing: 0.012307882308959961 seconds, ~0%
Time spent prepping for tree search: 0.3938724994659424 seconds, ~1%
Time spent searching for tree: 0.8115088939666748 seconds, ~2%
Total of ~94% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:45:40

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.31407642364502 seconds
Number of tilings expanded by Set 1 is 280
Number of tilings expanded by Set 2 is 214
Total number of tilings is 1347
Total number of expandable tilings is 1283
Total number of verified tilings is 142
Total number of strategy verified tilings is 78
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.7814083099365234 seconds, ~2%
Time spent strategy verifying: 0.1493372917175293 seconds, ~0%
Time spent inferring: 15.509392738342285 seconds, ~51%
Time spent expanding Set 1: 7.5033440589904785 seconds, ~24%
Time spent expanding Set 2: 0.38228726387023926 seconds, ~1%
Time spent queueing: 0.017162799835205078 seconds, ~0%
Time spent prepping for tree search: 0.8306112289428711 seconds, ~2%
Time spent searching for tree: 1.6898536682128906 seconds, ~5%
Total of ~85% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:46:11

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.09893250465393 seconds
Number of tilings expanded by Set 1 is 208
Number of tilings expanded by Set 2 is 111
Total number of tilings is 830
Total number of expandable tilings is 782
Total number of verified tilings is 120
Total number of strategy verified tilings is 65
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 0.8602185249328613 seconds, ~2%
Time spent strategy verifying: 0.11757111549377441 seconds, ~0%
Time spent inferring: 8.138404369354248 seconds, ~27%
Time spent expanding Set 1: 17.98159670829773 seconds, ~59%
Time spent expanding Set 2: 0.17300748825073242 seconds, ~0%
Time spent queueing: 0.01477813720703125 seconds, ~0%
Time spent prepping for tree search: 0.45804882049560547 seconds, ~1%
Time spent searching for tree: 1.0253849029541016 seconds, ~3%
Total of ~92% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:46:41

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.056795120239258 seconds
Number of tilings expanded by Set 1 is 314
Number of tilings expanded by Set 2 is 174
Total number of tilings is 1272
Total number of expandable tilings is 1192
Total number of verified tilings is 187
Total number of strategy verified tilings is 90
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 1.4241337776184082 seconds, ~4%
Time spent strategy verifying: 0.1743612289428711 seconds, ~0%
Time spent inferring: 14.074662208557129 seconds, ~46%
Time spent expanding Set 1: 8.665204286575317 seconds, ~28%
Time spent expanding Set 2: 0.3052055835723877 seconds, ~1%
Time spent queueing: 0.020949125289916992 seconds, ~0%
Time spent prepping for tree search: 1.0304591655731201 seconds, ~3%
Time spent searching for tree: 2.408221960067749 seconds, ~8%
Total of ~90% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 14:47:11

Looking for proof tree for Basis((Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))))

The strategies being used are:
Equivalent: all_equivalent_row_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 5.829248905181885 seconds
Number of tilings expanded by Set 1 is 52
Number of tilings expanded by Set 2 is 48
Total number of tilings is 216
Total number of expandable tilings is 173
Total number of verified tilings is 127
Total number of strategy verified tilings is 55
Total number of empty tilings is 2
There were 0 cache misses

Time spent equivalent expanding: 0.028189897537231445 seconds, ~0%
Time spent strategy verifying: 0.14571452140808105 seconds, ~2%
Time spent inferring: 0.9131805896759033 seconds, ~15%
Time spent expanding Set 1: 4.1107447147369385 seconds, ~70%
Time spent expanding Set 2: 0.05670738220214844 seconds, ~0%
Time spent queueing: 0.004370212554931641 seconds, ~0%
Time spent prepping for tree search: 0.042766571044921875 seconds, ~0%
Time spent searching for tree: 0.2589573860168457 seconds, ~4%
Total of ~91% accounted for.

Proof tree found Mon, 18 Sep 2017 14:47:17

root: 0
      ├─────1
      └─────2
            ├─────3
            └─────4
                  ├─────5
                  │     ├─────6
                  │     │     ├─────7
                  │     │     └─────8
                  │     │           ├─────9
                  │     │           └─────10
                  │     │                 ├─────11
                  │     │                 └─────12
                  │     └─────13
                  │           ├─────14
                  │           │     ├─────15
                  │           │     └─────16
                  │           │           ├─────17
                  │           │           └─────18
                  │           └─────19
                  └─────20

Label: 0

+-+
|1|
+-+
1: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))

Label: 1

+-+
| |
+-+


Label: 2

+-+
|1|
+-+
1: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
We use his sibling for the next strategy
+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 3

+-+-+
| |2|
+-+-+
|1| |
+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: point

Label: 4

+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av(Perm((0, 1)), Perm((2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 5

+-+-+-+
| |3| |
+-+-+-+
|1| |2|
+-+-+-+
1: Av+(Perm((0, 1)), Perm((2, 1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 6

+-+-+-+-+
| | |3| |
+-+-+-+-+
|3| | | |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 7

+-+-+-+
| |2| |
+-+-+-+
|2| | |
+-+-+-+
| | |1|
+-+-+-+
1: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
2: point

Label: 8

+-+-+-+-+
| | |1| |
+-+-+-+-+
|1| | | |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: point
2: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))

Label: 9

+-+-+-+-+
| | |2| |
+-+-+-+-+
|2| | | |
+-+-+-+-+
| |2| | |
+-+-+-+-+
| | | |1|
+-+-+-+-+
1: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
2: point

Label: 10

+-+-+-+-+-+-+
| | |3| | | |
+-+-+-+-+-+-+
|3| | | | | |
+-+-+-+-+-+-+
| | | | |3| |
+-+-+-+-+-+-+
| |3| | | | |
+-+-+-+-+-+-+
| | | |1| |2|
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 11

+-+
|1|
+-+
1: point

Label: 12

+-+-+-+-+-+
| |3| | | |
+-+-+-+-+-+
| | | |3| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| | |1| |2|
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 13

+-+-+-+-+-+
| |4| | | |
+-+-+-+-+-+
| | | |4| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| | |1| |2|
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: Av+(Perm((0, 1)), Perm((2, 1, 0)))
4: point
We use his sibling for the next strategy
+-+-+-+-+-+-+
| | |3| | | |
+-+-+-+-+-+-+
| | | | |3| |
+-+-+-+-+-+-+
|3| | | | | |
+-+-+-+-+-+-+
| |1| | | | |
+-+-+-+-+-+-+
| | | |1| |2|
+-+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 14

+-+-+-+-+-+
| |3| | | |
+-+-+-+-+-+
| | | |3| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| | |1| |2|
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 15

+-+-+-+-+
| |2| | |
+-+-+-+-+
| | | |2|
+-+-+-+-+
|2| | | |
+-+-+-+-+
| | |1| |
+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: point

Label: 16

+-+-+-+-+-+
| |3| | | |
+-+-+-+-+-+
| | | |3| |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| | |1| |2|
+-+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 17

+-+-+-+-+
| | |3| |
+-+-+-+-+
|3| | | |
+-+-+-+-+
| |1| |2|
+-+-+-+-+
1: Av(Perm((0, 1)), Perm((1, 0)))
2: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
3: point

Label: 18

+-+
|1|
+-+
1: point

Label: 19

+-+-+-+-+-+
| | |2| | |
+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
|2| | | | |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
1: Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
2: point

Label: 20

+-+-+
|2| |
+-+-+
| |1|
+-+-+
1: Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))
2: point
{"root": {"formal_step": "We perform cell insertion into cell (0, 0); either it is empty or Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))).", "in_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))"}, "relation": "", "identifier": 0, "children": [{"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {}, "out_tiling": {}, "relation": "", "identifier": 1, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (2, 0); either it is empty or Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))).", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=0, j=0). | ", "identifier": 3, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[0, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[1, 1]": "point"}, "relation": "", "identifier": 7, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (0, 0); either it is empty or Av+(Perm((0, 1)), Perm((2, 1, 0))).", "in_tiling": {"[0, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point"}, "relation": "", "identifier": 8, "children": [{"formal_step": "Placing the maximum point into row 0", "in_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[2, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point"}, "relation": "", "identifier": 14, "children": [{"formal_step": "We perform cell insertion into cell (1, 0); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[2, 2]": "point"}, "out_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[2, 2]": "point"}, "relation": "", "identifier": 29, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[1, 2]": "point"}, "out_tiling": {"[2, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[1, 2]": "point"}, "relation": "", "identifier": 63, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "Placing the maximum point into row 0", "in_tiling": {"[1, 0]": "point", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[2, 2]": "point"}, "out_tiling": {"[1, 0]": "point", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[2, 2]": "point"}, "relation": "", "identifier": 62, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point", "[0, 2]": "point", "[2, 3]": "point"}, "out_tiling": {"[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point", "[0, 2]": "point", "[2, 3]": "point"}, "relation": "", "identifier": 152, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "Reversibly delete the blocks at cells [Cell(i=0, j=3)]", "in_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point", "[4, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point", "[4, 2]": "point", "[0, 3]": "point", "[2, 4]": "point"}, "relation": "", "identifier": 151, "children": [{"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {"[0, 0]": "point"}, "out_tiling": {"[0, 0]": "point"}, "relation": "", "identifier": 40, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "recurse", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 52, "children": [], "recurse": "[]", "strategy_verified": false}], "recurse": "[{Cell(i=0, j=1): Cell(i=1, j=1), Cell(i=1, j=3): Cell(i=2, j=4), Cell(i=2, j=0): Cell(i=3, j=0), Cell(i=3, j=2): Cell(i=4, j=2), Cell(i=4, j=0): Cell(i=5, j=0)}, {Cell(i=0, j=0): Cell(i=0, j=3)}]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "We perform cell insertion into cell (1, 1); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "Av+(Perm((0, 1)), Perm((2, 1, 0)))", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[3, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[5, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 2]": "point", "[4, 3]": "point", "[2, 4]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=0, j=1). | ", "identifier": 31, "children": [{"formal_step": "We perform cell insertion into cell (4, 0); either it is empty or Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3))).", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 52, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 97, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "Reversibly delete the blocks at cells [Cell(i=1, j=3)]", "in_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[4, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[3, 2]": "point", "[1, 3]": "point"}, "relation": "", "identifier": 98, "children": [{"formal_step": "recurse", "in_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[2, 2]": "point"}, "out_tiling": {"[1, 0]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point", "[2, 2]": "point"}, "relation": "", "identifier": 29, "children": [], "recurse": "[]", "strategy_verified": false}, {"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {"[0, 0]": "point"}, "out_tiling": {"[0, 0]": "point"}, "relation": "", "identifier": 40, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[{Cell(i=0, j=1): Cell(i=0, j=1), Cell(i=1, j=0): Cell(i=2, j=0), Cell(i=2, j=2): Cell(i=3, j=2), Cell(i=3, j=0): Cell(i=4, j=0)}, {Cell(i=0, j=0): Cell(i=1, j=3)}]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[4, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point", "[0, 2]": "point", "[3, 3]": "point", "[2, 4]": "point"}, "out_tiling": {"[4, 0]": "Av(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[1, 1]": "point", "[0, 2]": "point", "[3, 3]": "point", "[2, 4]": "point"}, "relation": "", "identifier": 53, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[1, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point"}, "out_tiling": {"[1, 0]": "Av+(Perm((0, 1, 2)), Perm((0, 3, 2, 1)), Perm((2, 1, 0, 3)))", "[0, 1]": "point"}, "relation": "", "identifier": 18, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}}
Time taken was 5.829248905181885 seconds

