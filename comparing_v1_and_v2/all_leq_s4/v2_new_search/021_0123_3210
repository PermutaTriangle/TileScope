021_0123_3210
Symmetry: False
Non-Interleaving Decompoition: False
Tiling Queue: <class 'atrapv2.tilingqueue.TilingQueue'>

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 18:05:43

Looking for proof tree for Basis((Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.060224294662476 seconds
Number of tilings expanded by Set 1 is 243
Number of tilings expanded by Set 2 is 215
Total number of tilings is 1751
Total number of expandable tilings is 1574
Total number of verified tilings is 187
Total number of strategy verified tilings is 83
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 1.1379001140594482 seconds, ~3%
Time spent strategy verifying: 0.3808009624481201 seconds, ~1%
Time spent inferring: 11.537468433380127 seconds, ~38%
Time spent expanding Set 1: 6.402911186218262 seconds, ~21%
Time spent expanding Set 2: 0.6207799911499023 seconds, ~2%
Time spent queueing: 0.021629810333251953 seconds, ~0%
Time spent prepping for tree search: 1.264265537261963 seconds, ~4%
Time spent searching for tree: 1.7630717754364014 seconds, ~5%
Total of ~74% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 18:06:13

Looking for proof tree for Basis((Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.007246255874634 seconds
Number of tilings expanded by Set 1 is 243
Number of tilings expanded by Set 2 is 189
Total number of tilings is 1582
Total number of expandable tilings is 1402
Total number of verified tilings is 178
Total number of strategy verified tilings is 78
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.9979264736175537 seconds, ~3%
Time spent strategy verifying: 0.35431647300720215 seconds, ~1%
Time spent inferring: 10.00727391242981 seconds, ~33%
Time spent expanding Set 1: 8.97339415550232 seconds, ~29%
Time spent expanding Set 2: 0.5440089702606201 seconds, ~1%
Time spent queueing: 0.01932239532470703 seconds, ~0%
Time spent prepping for tree search: 1.1414637565612793 seconds, ~3%
Time spent searching for tree: 1.6186738014221191 seconds, ~5%
Total of ~75% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 18:06:43

Looking for proof tree for Basis((Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.003434896469116 seconds
Number of tilings expanded by Set 1 is 266
Number of tilings expanded by Set 2 is 156
Total number of tilings is 1455
Total number of expandable tilings is 1345
Total number of verified tilings is 127
Total number of strategy verified tilings is 52
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 2.1321897506713867 seconds, ~7%
Time spent strategy verifying: 0.18357443809509277 seconds, ~0%
Time spent inferring: 12.720998287200928 seconds, ~42%
Time spent expanding Set 1: 9.61508846282959 seconds, ~32%
Time spent expanding Set 2: 0.2821695804595947 seconds, ~0%
Time spent queueing: 0.018840551376342773 seconds, ~0%
Time spent prepping for tree search: 0.8734254837036133 seconds, ~2%
Time spent searching for tree: 0.9774794578552246 seconds, ~3%
Total of ~86% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 18:07:14

Looking for proof tree for Basis((Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements, all_equivalent_column_placements, point_separation
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_row_placements, all_column_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.124699354171753 seconds
Number of tilings expanded by Set 1 is 320
Number of tilings expanded by Set 2 is 167
Total number of tilings is 1531
Total number of expandable tilings is 1400
Total number of verified tilings is 144
Total number of strategy verified tilings is 57
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 2.304291248321533 seconds, ~7%
Time spent strategy verifying: 0.20342397689819336 seconds, ~0%
Time spent inferring: 14.562752962112427 seconds, ~48%
Time spent expanding Set 1: 6.926334619522095 seconds, ~22%
Time spent expanding Set 2: 0.30649399757385254 seconds, ~1%
Time spent queueing: 0.022860050201416016 seconds, ~0%
Time spent prepping for tree search: 1.17854905128479 seconds, ~3%
Time spent searching for tree: 1.8693387508392334 seconds, ~6%
Total of ~87% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 18:07:44

Looking for proof tree for Basis((Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.10989999771118 seconds
Number of tilings expanded by Set 1 is 266
Number of tilings expanded by Set 2 is 125
Total number of tilings is 1405
Total number of expandable tilings is 1304
Total number of verified tilings is 124
Total number of strategy verified tilings is 54
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 2.97967529296875 seconds, ~9%
Time spent strategy verifying: 0.1578524112701416 seconds, ~0%
Time spent inferring: 12.042277097702026 seconds, ~39%
Time spent expanding Set 1: 10.97981882095337 seconds, ~36%
Time spent expanding Set 2: 0.21414566040039062 seconds, ~0%
Time spent queueing: 0.016999244689941406 seconds, ~0%
Time spent prepping for tree search: 0.7054769992828369 seconds, ~2%
Time spent searching for tree: 1.508770227432251 seconds, ~5%
Total of ~91% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 18:08:14

Looking for proof tree for Basis((Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: point_separation, all_equivalent_point_isolations
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: splittings
Set 2: all_cell_insertions, all_point_isolations

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 30.105116844177246 seconds
Number of tilings expanded by Set 1 is 300
Number of tilings expanded by Set 2 is 160
Total number of tilings is 1714
Total number of expandable tilings is 1584
Total number of verified tilings is 153
Total number of strategy verified tilings is 63
Total number of empty tilings is 1
There were 0 cache misses

Time spent equivalent expanding: 3.783552408218384 seconds, ~12%
Time spent strategy verifying: 0.1896209716796875 seconds, ~0%
Time spent inferring: 16.57600450515747 seconds, ~55%
Time spent expanding Set 1: 5.3632493019104 seconds, ~17%
Time spent expanding Set 2: 0.269273042678833 seconds, ~0%
Time spent queueing: 0.018519878387451172 seconds, ~0%
Time spent prepping for tree search: 1.0085844993591309 seconds, ~3%
Time spent searching for tree: 1.4624478816986084 seconds, ~4%
Total of ~91% accounted for.

Exceeded maximum time. Aborting auto search.

--------------------------------------------------------------------------
Trying: No name
Auto search started Mon, 18 Sep 2017 18:08:44

Looking for proof tree for Basis((Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))))

The strategies being used are:
Equivalent: all_equivalent_row_placements
Inferral: empty_cell_inferral, row_and_column_separation, subclass_inferral
Verification: subset_verified
Set 1: components, reversibly_deletable_cells
Set 2: all_cell_insertions, all_row_placements

 ------------- 
|STATUS UPDATE|
 ------------- 

Time spent searching so far: 14.788749933242798 seconds
Number of tilings expanded by Set 1 is 174
Number of tilings expanded by Set 2 is 147
Total number of tilings is 1041
Total number of expandable tilings is 685
Total number of verified tilings is 391
Total number of strategy verified tilings is 145
Total number of empty tilings is 0
There were 0 cache misses

Time spent equivalent expanding: 0.2516899108886719 seconds, ~1%
Time spent strategy verifying: 0.4086949825286865 seconds, ~2%
Time spent inferring: 4.2496337890625 seconds, ~28%
Time spent expanding Set 1: 3.058084011077881 seconds, ~20%
Time spent expanding Set 2: 0.2957336902618408 seconds, ~1%
Time spent queueing: 0.01654815673828125 seconds, ~0%
Time spent prepping for tree search: 0.7892355918884277 seconds, ~5%
Time spent searching for tree: 2.623619556427002 seconds, ~17%
Total of ~74% accounted for.

Proof tree found Mon, 18 Sep 2017 18:08:59

root: 0
      ├─────1
      └─────2
            ├─────3
            └─────4
                  ├─────5
                  │     ├─────6
                  │     └─────7
                  │           ├─────8
                  │           └─────9
                  │                 ├─────10
                  │                 └─────11
                  └─────12

Label: 0

+-+
|1|
+-+
1: Av(Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0)))

Label: 1

+-+
| |
+-+


Label: 2

+-+
|1|
+-+
1: Av+(Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0)))
We use his sibling for the next strategy
+-+-+-+
| |3| |
+-+-+-+
|2| | |
+-+-+-+
| | |1|
+-+-+-+
1: Av(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))
2: Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((3, 2, 1, 0)))
3: point

Label: 3

+-+-+
| |2|
+-+-+
|1| |
+-+-+
1: Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((3, 2, 1, 0)))
2: point

Label: 4

+-+-+-+
| |3| |
+-+-+-+
|2| | |
+-+-+-+
| | |1|
+-+-+-+
1: Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))
2: Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((2, 1, 0)))
3: point
We use his sibling for the next strategy
+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
|4| | | | |
+-+-+-+-+-+
| | |2| |3|
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point
2: Av(Perm((1, 0)), Perm((0, 1, 2, 3)))
3: Av(Perm((1, 0)), Perm((0, 1, 2)))
4: Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((2, 1, 0)))

Label: 5

+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
|4| | | | |
+-+-+-+-+-+
| | |2| |3|
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point
2: Av(Perm((1, 0)), Perm((0, 1, 2, 3)))
3: Av(Perm((1, 0)), Perm((0, 1, 2)))
4: Av+(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((2, 1, 0)))
We use his sibling for the next strategy
+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
|3| |4| | |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
1: Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))
2: point
3: Av(Perm((1, 0)), Perm((0, 1, 2)))
4: Av(Perm((0, 1)), Perm((1, 0)))

Label: 6

+-+-+-+-+
| | |2| |
+-+-+-+-+
| |3| | |
+-+-+-+-+
|2| | | |
+-+-+-+-+
| | | |1|
+-+-+-+-+
1: Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))
2: point
3: Av(Perm((0, 1)), Perm((1, 0)))

Label: 7

+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
|3| |4| | |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
1: Av+(Perm((1, 0)), Perm((0, 1, 2, 3)))
2: point
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))
4: Av(Perm((0, 1)), Perm((1, 0)))
We use his sibling for the next strategy
+-+-+-+-+-+-+
| | | |2| | |
+-+-+-+-+-+-+
|3| |4| | | |
+-+-+-+-+-+-+
| |2| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
1: Av(Perm((1, 0)), Perm((0, 1, 2)))
2: point
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))
4: Av(Perm((0, 1)), Perm((1, 0)))

Label: 8

+-+-+-+-+-+
| | |2| | |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: Av(Perm((1, 0)), Perm((0, 1, 2)))
2: point
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))
We use his sibling for the next strategy
+-+-+-+-+-+
| | |1| | |
+-+-+-+-+-+
|3| | | | |
+-+-+-+-+-+
| |1| | | |
+-+-+-+-+-+
| | | | |2|
+-+-+-+-+-+
| | | |1| |
+-+-+-+-+-+
1: point
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))

Label: 9

+-+-+-+-+-+-+
| | | |2| | |
+-+-+-+-+-+-+
|3| |2| | | |
+-+-+-+-+-+-+
| |2| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
1: Av(Perm((1, 0)), Perm((0, 1, 2)))
2: point
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))
We use his sibling for the next strategy
+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
|3| |1| | | |
+-+-+-+-+-+-+
| |1| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
1: point
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))

Label: 10

+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
| | |1| | | |
+-+-+-+-+-+-+
|1| | | | | |
+-+-+-+-+-+-+
| |1| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
1: point
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
We use his sibling for the next strategy
+-+-+-+-+-+
| | | |2| |
+-+-+-+-+-+
| | |2| | |
+-+-+-+-+-+
|2| | | | |
+-+-+-+-+-+
| |2| | | |
+-+-+-+-+-+
| | | | |1|
+-+-+-+-+-+
1: Av+(Perm((1, 0)), Perm((0, 1, 2, 3)))
2: point

Label: 11

+-+-+-+-+-+-+
| | | |1| | |
+-+-+-+-+-+-+
|3| | | | | |
+-+-+-+-+-+-+
| | |1| | | |
+-+-+-+-+-+-+
| |1| | | | |
+-+-+-+-+-+-+
| | | | | |2|
+-+-+-+-+-+-+
| | | | |1| |
+-+-+-+-+-+-+
1: point
2: Av(Perm((1, 0)), Perm((0, 1, 2)))
3: Av+(Perm((1, 0)), Perm((0, 1, 2)))
We use his sibling for the next strategy
+-+-+-+-+-+-+
| | | | |2| |
+-+-+-+-+-+-+
| |2| | | | |
+-+-+-+-+-+-+
|3| | | | | |
+-+-+-+-+-+-+
| | | |2| | |
+-+-+-+-+-+-+
| | |2| | | |
+-+-+-+-+-+-+
| | | | | |1|
+-+-+-+-+-+-+
1: Av+(Perm((1, 0)), Perm((0, 1, 2, 3)))
2: point
3: Av(Perm((0, 1)), Perm((1, 0)))

Label: 12

+-+-+-+-+
|1| | | |
+-+-+-+-+
| |2| |3|
+-+-+-+-+
| | |1| |
+-+-+-+-+
1: point
2: Av(Perm((1, 0)), Perm((0, 1, 2, 3)))
3: Av(Perm((1, 0)), Perm((0, 1, 2)))
We use his sibling for the next strategy
+-+-+
|2| |
+-+-+
| |1|
+-+-+
1: Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))
2: point
{"root": {"formal_step": "We perform cell insertion into cell (0, 0); either it is empty or Av+(Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0))).", "in_tiling": {"[0, 0]": "Av(Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0)))"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0)))"}, "relation": "", "identifier": 0, "children": [{"formal_step": "Verified because it is a one by one tiling with a subclass", "in_tiling": {}, "out_tiling": {}, "relation": "", "identifier": 1, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (2, 0); either it is empty or Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3))).", "in_tiling": {"[0, 0]": "Av+(Perm((0, 2, 1)), Perm((0, 1, 2, 3)), Perm((3, 2, 1, 0)))"}, "out_tiling": {"[2, 0]": "Av(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))", "[0, 1]": "Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((3, 2, 1, 0)))", "[1, 2]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=0, j=0). | ", "identifier": 3, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((3, 2, 1, 0)))", "[1, 1]": "point"}, "out_tiling": {"[0, 0]": "Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((3, 2, 1, 0)))", "[1, 1]": "point"}, "relation": "", "identifier": 12, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (0, 2); either it is empty or Av+(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((2, 1, 0))).", "in_tiling": {"[2, 0]": "Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))", "[0, 1]": "Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((2, 1, 0)))", "[1, 2]": "point"}, "out_tiling": {"[3, 0]": "point", "[2, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2, 3)))", "[4, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[0, 2]": "Av(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((2, 1, 0)))", "[1, 3]": "point"}, "relation": "| Inserting the bottom most point in to the cell Cell(i=2, j=0). | ", "identifier": 14, "children": [{"formal_step": "We perform cell insertion into cell (0, 2); either it is empty or Av+(Perm((1, 0)), Perm((0, 1, 2))).", "in_tiling": {"[3, 0]": "point", "[2, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2, 3)))", "[4, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[0, 2]": "Av+(Perm((0, 1, 2)), Perm((0, 2, 1)), Perm((2, 1, 0)))", "[1, 3]": "point"}, "out_tiling": {"[4, 0]": "Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))", "[1, 1]": "point", "[0, 2]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 2]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 3]": "point"}, "relation": "| Inserting the bottom most point in to the cell Cell(i=0, j=2). | Reverse of: Inserting the bottom most point in to the cell Cell(i=4, j=0). | ", "identifier": 48, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))", "[0, 1]": "point", "[1, 2]": "Av(Perm((0, 1)), Perm((1, 0)))", "[2, 3]": "point"}, "out_tiling": {"[3, 0]": "Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))", "[0, 1]": "point", "[1, 2]": "Av(Perm((0, 1)), Perm((1, 0)))", "[2, 3]": "point"}, "relation": "", "identifier": 118, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "We perform cell insertion into cell (2, 3); either it is empty or Av+(Perm((0, 1)), Perm((1, 0))).", "in_tiling": {"[4, 0]": "Av+(Perm((1, 0)), Perm((0, 1, 2, 3)))", "[1, 1]": "point", "[0, 2]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 2]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 3]": "point"}, "out_tiling": {"[4, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[5, 1]": "point", "[1, 2]": "point", "[0, 3]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 3]": "Av(Perm((0, 1)), Perm((1, 0)))", "[3, 4]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=4, j=0). | ", "identifier": 120, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[3, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[4, 1]": "point", "[1, 2]": "point", "[0, 3]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 4]": "point"}, "out_tiling": {"[3, 0]": "point", "[4, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 4]": "point"}, "relation": "| Reverse of: Inserting the top most point in to the cell Cell(i=3, j=0). | Inserting the bottom most point in to the cell Cell(i=3, j=0). | ", "identifier": 443, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "Placing the minimum point into row 3", "in_tiling": {"[4, 0]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[5, 1]": "point", "[1, 2]": "point", "[0, 3]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 3]": "point", "[3, 4]": "point"}, "out_tiling": {"[4, 0]": "point", "[5, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[2, 3]": "point", "[3, 4]": "point"}, "relation": "| Reverse of: Inserting the top most point in to the cell Cell(i=4, j=0). | Inserting the bottom most point in to the cell Cell(i=4, j=0). | ", "identifier": 769, "children": [{"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[4, 0]": "point", "[5, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[0, 3]": "point", "[2, 4]": "point", "[3, 5]": "point"}, "out_tiling": {"[4, 0]": "Av+(Perm((1, 0)), Perm((0, 1, 2, 3)))", "[1, 1]": "point", "[0, 2]": "point", "[2, 3]": "point", "[3, 4]": "point"}, "relation": "| Reverse of: Inserting the bottom most point in to the cell Cell(i=4, j=0). | ", "identifier": 606, "children": [], "recurse": "[]", "strategy_verified": true}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[4, 0]": "point", "[5, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[1, 2]": "point", "[2, 3]": "point", "[0, 4]": "Av+(Perm((1, 0)), Perm((0, 1, 2)))", "[3, 5]": "point"}, "out_tiling": {"[5, 0]": "Av+(Perm((1, 0)), Perm((0, 1, 2, 3)))", "[2, 1]": "point", "[3, 2]": "point", "[0, 3]": "Av(Perm((0, 1)), Perm((1, 0)))", "[1, 4]": "point", "[4, 5]": "point"}, "relation": "| Inserting the top most point in to the cell Cell(i=0, j=4). | Reverse of: Inserting the bottom most point in to the cell Cell(i=5, j=0). | ", "identifier": 907, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}, {"formal_step": "The tiling is a subset of the subclass", "in_tiling": {"[2, 0]": "point", "[1, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2, 3)))", "[3, 1]": "Av(Perm((1, 0)), Perm((0, 1, 2)))", "[0, 2]": "point"}, "out_tiling": {"[1, 0]": "Av+(Perm((0, 2, 1)), Perm((2, 1, 0)), Perm((0, 1, 2, 3)))", "[0, 1]": "point"}, "relation": "| Reverse of: Inserting the bottom most point in to the cell Cell(i=1, j=0). | ", "identifier": 64, "children": [], "recurse": "[]", "strategy_verified": true}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}], "recurse": "[]", "strategy_verified": false}}
Time taken was 14.788749933242798 seconds

