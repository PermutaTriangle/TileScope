# ATRAP

ATRAP is an algorithm that builds a proof tree using several different proof
strategies. The goal is to make the algorithm powerful enough to find proof
trees that allow us to enumerate permutation classes avoiding patterns of length
four. In the beginning we will start with a relatively simple algorithm that can
handle bases with many length four patterns. As we consider smaller bases we
will start seeing the algorithm fail and will then add new strategies to turn
those failures into successes. We feel that it is natural to start with a known
approach to connect with the current state of the literature. Currently we want
to take the regular insertion encoding as the starting point. This is mainly
because this is the only automatic method for which you can know a priori
whether or not it will succeed. This depends on whether the basis of the
permutation class intersects the permutation classes Av(123, 3142, 3412) and
Av(132, 312), as well as the reversals of these classes. As the goal is to
consider all bases of length four patterns, this condition allows us discard a
large number of bases and focus on more complicated ones.

Quick note on the current version: We have a version implementing strategies
that do not achieve mimicking regular insertion encoding. That version is hard
to add to so we are starting from scratch. The current version is however quite
powerful: It seems to be able to do all bases with at least one length three
and one length four pattern, as well as doing several interesting bases with
length four patterns.

## Roadmap

### Step 1: Mimick the regular insertion encoding
Recall how regular cell insertion finds the structure of the class Av(123, 132):

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/rie_123_132.jpg "Regular insertion encoding of Av(123, 132)")

The most basic implementation of ATRAP mimicks the regular insertion encoding.
Notation for the next figure: X is a permutation class, epsilong (e here) is the
empty permutation, X with a dot in the middle (X-e here) is a class with the
empty permutation removed, and o is the point. We start with X at the root and
use the following proof strategy to branch:

_Cell specialization (cs)_: Given a cell marked with an X, create a left child
with X replaced by e, and a right child with X replaced by X-e.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/basic_atrap_123_132.jpg "ATRAP mimicking regular insertion encoding")

The left child is 'verified' meaning that it represents a subset of the class X.
To progress from the right child we need a new proof strategy:

_Insert new maximum (nm)_: If there are no cells marked with 'X' in the top row of
the tiling then branch (into as many branches as there are X-e's) depending on
where the new maximum is. Note that illegal placements of the new maximum are
not drawn. (Also note that when this is applied with a single X-e then we don't
draw an edge pointing down, but rather an '=' since this is just another
viewpoint on the same subset of X.)

To mimick the loops in the automaton created by regular insertion encoding we
borrow reversibly-deletable points from enumeration schemes: A point o is
reversibly-deletable if there is an isomorphism between the subset of the class
X generated by a tiling T, and the subset of the class X generated by a tiling
T-o. We call this strategy _recursion (r)_. These are drawn with dashed arrows.

It should be easy to argue that this version of ATRAP is equivalent to regular
insertion encoding. The proof trees outputted by it should also be easily
turned into generating functions for the classes.

A final note on this version: Since we need to turn all X's in the top row into
X-e's before we can apply (nm) this implies that the algorithm explores exactly
one proof tree. This will change below when we have multiple choices for
proceeding from a tiling.

### Step 2: Generalizing (nm) and (r), adding (pp) and (rcs), and inferral of cells in a tiling
A natural generalization of (nm) is choosing a row or column and inserting a
new bottom-most or top-most point in the row; or a left-most or right-most point
in the column. We call this strategy row/column insertion (rci).

It is not settled what the first generalization of (r) will be, but probably
at least allowing reversibly-deletable cells (not just points). Also keep in
mind that non-ancestral recursions are easier to implement and understand.
Also note that recursions that stay within a proof tree are easier to
understand.

Instead of having to consider entire rows or columns when inserting new points
we can take a cell marked with X-e and insert the top-most, bottom-most,
left-most, or right-most point into it. This is _point-placement (pp)_.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/pp.jpg "I like to think of these as different viewpoints on the same subset")

The proof strategy _row-column separation (rcs)_ splits rows or columns depending
on whether crossing 12's or 21's are allowed. Think of the structure of
Av(231). Christian has generalized this to multiple cells in a row or a column.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/rcs.jpg "If a crossing 21 is forbidden, split the row")

Finally, whenever we apply a proof strategy that adds a point or an X-e we
should _infer_ what the rest of the cells need to avoid, instead of just marking
them with an X.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/inf.jpg "The right-most cell must be decreasing")

With these proof strategies we should be able to find a proof tree for any
Av(B) such that B contains at least one length 3 pattern and one length 4
pattern.

At this stage I think a paper with the above results is in order.

Note that we can get a proof tree for Av(123) but it does not easily imply that
the class is counted by the Catalan numbers, see Step 3.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/current_atrap_123.jpg "Note that there is a decreasing cell that mixes into the recursed part")

### Step 3: Generalizing (cs) and (r), adding fission/fusion (ff)
To be able to mimick Zeilberger's original enumeration schemes we need to have
_fission and fusions (ff)_ of rows and columns.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/ff.jpg "PSd = fission/fusion, PSe = row/column insertion")

Here is the enumeration scheme given by Zeilberger (he wrote it out in plain
English.)

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/es123.jpg "PSd = fission/fusion, PSe = row/column insertion")

With these proof strategies we can find Zeilberger's original enumeration
schemes. In particular we will be able to find very similar trees for Av(123)
and Av(132). The following tree is for Av(132)

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/es132.jpg "Sorry for the bad handwriting")

If we define isomorphisms of proof trees we can prove these are Wilf-equivalent.
From Step 2 we will have established that Av(132) is enumerated by the Catalan
numbers. This will finally give us a fully automatic Wilf-classification of all
subsets of S3.

The strategy (cs) creates two branches depending on whether a cell avoids the
pattern 1 (= is empty) or contains the pattern 1 (= is non-empty). This can be
generalized by replacing 1 with an arbitrary pattern p. Note that when we use
(pp) on a cell which we know contains a pattern p we need to use a binary mesh
pattern coincident with p. We call these strategies (csp) and (bmp). Note that
(csp) would imply we can do any Av(132, p) where p is any pattern (see paper by
Toufik and someone else).

At this stage we probably want to allow several recursions into the same tiling,
as well as recursions outside of the actual proof tree.

A natural follow-up being able to automatically Wilf-classify S3 is to try to do
as much as possible of S4. A nice goal would be at least all bases with four or
more patterns.

### Step 4, assuming there are still bases in S4 left: Gap matrices
Vatter defined gap vectors for his enumeration schemes. In some sense they are
tools for early termination of the nodes in the scheme. Our nodes are
two-dimensional so we can define (completely analogously) gap matrices

There is a slight generalization of (rcs) which might be useful at some point:
Branch into a left child where there is no crossing 12 between two cells, and
a right child where there is a crossing 12. This only works if the crossing 12
can be made unique some how (similar to a binary mesh pattern).

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/321_1342.jpg "A crossing inversion placed around the maximum")
